# Copyright 2025 Cisco Systems, Inc. and its affiliates
#
# SPDX-License-Identifier: Apache-2.0

# coding: utf-8

"""
    Cisco Secure Access API

    Unified OpenAPI spec for Cisco Secure Access APIs.

    The version of the OpenAPI document: v2.0.202510221109
    Contact: devnet@cisco.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from secure_access.models.add_network_tunnel_group_request import AddNetworkTunnelGroupRequest
from secure_access.models.filters_ntgs_object import FiltersNTGsObject
from secure_access.models.network_tunnel_group_response import NetworkTunnelGroupResponse
from secure_access.models.network_tunnel_groups_list import NetworkTunnelGroupsList
from secure_access.models.patch_network_tunnel_group_request_inner import PatchNetworkTunnelGroupRequestInner

from secure_access.api_client import ApiClient, RequestSerialized
from secure_access.api_response import ApiResponse
from secure_access.rest import RESTResponseType


class NetworkTunnelGroupsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_network_tunnel_group(
        self,
        add_network_tunnel_group_request: Annotated[AddNetworkTunnelGroupRequest, Field(description="Create the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NetworkTunnelGroupResponse:
        """Create Network Tunnel Group

        Create a Network Tunnel Group in the organization.

        :param add_network_tunnel_group_request: Create the Network Tunnel Group. (required)
        :type add_network_tunnel_group_request: AddNetworkTunnelGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_network_tunnel_group_serialize(
            add_network_tunnel_group_request=add_network_tunnel_group_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "NetworkTunnelGroupResponse",
            '400': "Model400ValidationError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '409': "Model409Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_network_tunnel_group_with_http_info(
        self,
        add_network_tunnel_group_request: Annotated[AddNetworkTunnelGroupRequest, Field(description="Create the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NetworkTunnelGroupResponse]:
        """Create Network Tunnel Group

        Create a Network Tunnel Group in the organization.

        :param add_network_tunnel_group_request: Create the Network Tunnel Group. (required)
        :type add_network_tunnel_group_request: AddNetworkTunnelGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_network_tunnel_group_serialize(
            add_network_tunnel_group_request=add_network_tunnel_group_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "NetworkTunnelGroupResponse",
            '400': "Model400ValidationError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '409': "Model409Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_network_tunnel_group_without_preload_content(
        self,
        add_network_tunnel_group_request: Annotated[AddNetworkTunnelGroupRequest, Field(description="Create the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Network Tunnel Group

        Create a Network Tunnel Group in the organization.

        :param add_network_tunnel_group_request: Create the Network Tunnel Group. (required)
        :type add_network_tunnel_group_request: AddNetworkTunnelGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_network_tunnel_group_serialize(
            add_network_tunnel_group_request=add_network_tunnel_group_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "NetworkTunnelGroupResponse",
            '400': "Model400ValidationError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '409': "Model409Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_network_tunnel_group_serialize(
        self,
        add_network_tunnel_group_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if add_network_tunnel_group_request is not None:
            _body_params = add_network_tunnel_group_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'oauthFlow'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/deployments/v2/networktunnelgroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_network_tunnel_group(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete Network Tunnel Group

        Delete a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_tunnel_group_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "Model400NTGIDError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_network_tunnel_group_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete Network Tunnel Group

        Delete a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_tunnel_group_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "Model400NTGIDError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_network_tunnel_group_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Network Tunnel Group

        Delete a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_tunnel_group_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
            '400': "Model400NTGIDError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_network_tunnel_group_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauthFlow'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/deployments/v2/networktunnelgroups/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network_tunnel_group(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NetworkTunnelGroupResponse:
        """Get Network Tunnel Group

        Get a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_tunnel_group_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupResponse",
            '400': "Model400NTGIDError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_tunnel_group_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NetworkTunnelGroupResponse]:
        """Get Network Tunnel Group

        Get a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_tunnel_group_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupResponse",
            '400': "Model400NTGIDError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_tunnel_group_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Network Tunnel Group

        Get a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_tunnel_group_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupResponse",
            '400': "Model400NTGIDError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_tunnel_group_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauthFlow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/deployments/v2/networktunnelgroups/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_network_tunnel_groups(
        self,
        filters: Annotated[Optional[FiltersNTGsObject], Field(description="Filter the network tunnel groups by one or more properties:  * **name** - The name of a network tunnel group. The value of `name` is a sequence of case-insensitive characters. * **exactName** - The sequence of case-insensitive characters that exactly match the name of the network tunnel group.   Including `exactName` as a filter, causes the system to ignore the `name` filter. * **networkTunnelGroupIds** - The comma-separated list of network tunnel group IDs. * **exactAuthIdPrefix** - The case-sensitive value of the network tunnel hub auth ID prefix or the IP. * **region** - The region for the network tunnel group. The value of `region` is a sequence of case-insensitive characters. * **status** - The status of the network tunnel group. Valid values are \"connected\", \"disconnected\", and \"warning\". * **duplicateCIDRs** - List the network tunnel groups that have duplicate CIDRs.   Provide the CIDRs and optionally provide the regional scope and region properties.   Enabling the regional scope allows the system to find only duplicates within the same region.   You can not use the `duplicateCIDRs` filter with any other filter.  Specify the filters in the JSON format.  Example:  ``` {     \"name\": \"Branch 1 Network Tunnel Group\",     \"region\": \"us-east-1\" } ``` or  Example:  ``` {     \"duplicateCIDRs\":     {         \"cidrs\": \"10.0.0.0/8,10.01.0.0/16\",         \"regionalScope\": true,         \"region\": \"us-east\"     } }")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="An integer that represents the place to start reading in the collection. When the offset is set to `0`, the system returns the first page from the collection. If the `limit` is 10, the `offset` for the next page is 10. The default value is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="An integer that represents the number of records to return in the response. The default value is 10.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specify the field the system will use to sort the items from the collection in the response.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Specify the sort order (ascending or descending) for the items in the response.")] = None,
        include_statuses: Annotated[Optional[StrictBool], Field(description="Specify whether to include the IPsec tunnel status field (`tunnelsStatus`) for each hub.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NetworkTunnelGroupsList:
        """List Network Tunnel Groups

        List the Network Tunnel Groups in the organization. If you enable the `includeStatuses` query parameter in your API request, the response includes the `tunnelsStatus` field. The maximum number of items in a hub's list of tunnel states (`tunnelsStatus`) is 10.

        :param filters: Filter the network tunnel groups by one or more properties:  * **name** - The name of a network tunnel group. The value of `name` is a sequence of case-insensitive characters. * **exactName** - The sequence of case-insensitive characters that exactly match the name of the network tunnel group.   Including `exactName` as a filter, causes the system to ignore the `name` filter. * **networkTunnelGroupIds** - The comma-separated list of network tunnel group IDs. * **exactAuthIdPrefix** - The case-sensitive value of the network tunnel hub auth ID prefix or the IP. * **region** - The region for the network tunnel group. The value of `region` is a sequence of case-insensitive characters. * **status** - The status of the network tunnel group. Valid values are \"connected\", \"disconnected\", and \"warning\". * **duplicateCIDRs** - List the network tunnel groups that have duplicate CIDRs.   Provide the CIDRs and optionally provide the regional scope and region properties.   Enabling the regional scope allows the system to find only duplicates within the same region.   You can not use the `duplicateCIDRs` filter with any other filter.  Specify the filters in the JSON format.  Example:  ``` {     \"name\": \"Branch 1 Network Tunnel Group\",     \"region\": \"us-east-1\" } ``` or  Example:  ``` {     \"duplicateCIDRs\":     {         \"cidrs\": \"10.0.0.0/8,10.01.0.0/16\",         \"regionalScope\": true,         \"region\": \"us-east\"     } }
        :type filters: FiltersNTGsObject
        :param offset: An integer that represents the place to start reading in the collection. When the offset is set to `0`, the system returns the first page from the collection. If the `limit` is 10, the `offset` for the next page is 10. The default value is 0.
        :type offset: int
        :param limit: An integer that represents the number of records to return in the response. The default value is 10.
        :type limit: int
        :param sort_by: Specify the field the system will use to sort the items from the collection in the response.
        :type sort_by: str
        :param sort_order: Specify the sort order (ascending or descending) for the items in the response.
        :type sort_order: str
        :param include_statuses: Specify whether to include the IPsec tunnel status field (`tunnelsStatus`) for each hub.
        :type include_statuses: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_network_tunnel_groups_serialize(
            filters=filters,
            offset=offset,
            limit=limit,
            sort_by=sort_by,
            sort_order=sort_order,
            include_statuses=include_statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupsList",
            '400': "Model400ListError",
            '401': "Model401Error",
            '403': "Model403Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_network_tunnel_groups_with_http_info(
        self,
        filters: Annotated[Optional[FiltersNTGsObject], Field(description="Filter the network tunnel groups by one or more properties:  * **name** - The name of a network tunnel group. The value of `name` is a sequence of case-insensitive characters. * **exactName** - The sequence of case-insensitive characters that exactly match the name of the network tunnel group.   Including `exactName` as a filter, causes the system to ignore the `name` filter. * **networkTunnelGroupIds** - The comma-separated list of network tunnel group IDs. * **exactAuthIdPrefix** - The case-sensitive value of the network tunnel hub auth ID prefix or the IP. * **region** - The region for the network tunnel group. The value of `region` is a sequence of case-insensitive characters. * **status** - The status of the network tunnel group. Valid values are \"connected\", \"disconnected\", and \"warning\". * **duplicateCIDRs** - List the network tunnel groups that have duplicate CIDRs.   Provide the CIDRs and optionally provide the regional scope and region properties.   Enabling the regional scope allows the system to find only duplicates within the same region.   You can not use the `duplicateCIDRs` filter with any other filter.  Specify the filters in the JSON format.  Example:  ``` {     \"name\": \"Branch 1 Network Tunnel Group\",     \"region\": \"us-east-1\" } ``` or  Example:  ``` {     \"duplicateCIDRs\":     {         \"cidrs\": \"10.0.0.0/8,10.01.0.0/16\",         \"regionalScope\": true,         \"region\": \"us-east\"     } }")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="An integer that represents the place to start reading in the collection. When the offset is set to `0`, the system returns the first page from the collection. If the `limit` is 10, the `offset` for the next page is 10. The default value is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="An integer that represents the number of records to return in the response. The default value is 10.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specify the field the system will use to sort the items from the collection in the response.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Specify the sort order (ascending or descending) for the items in the response.")] = None,
        include_statuses: Annotated[Optional[StrictBool], Field(description="Specify whether to include the IPsec tunnel status field (`tunnelsStatus`) for each hub.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NetworkTunnelGroupsList]:
        """List Network Tunnel Groups

        List the Network Tunnel Groups in the organization. If you enable the `includeStatuses` query parameter in your API request, the response includes the `tunnelsStatus` field. The maximum number of items in a hub's list of tunnel states (`tunnelsStatus`) is 10.

        :param filters: Filter the network tunnel groups by one or more properties:  * **name** - The name of a network tunnel group. The value of `name` is a sequence of case-insensitive characters. * **exactName** - The sequence of case-insensitive characters that exactly match the name of the network tunnel group.   Including `exactName` as a filter, causes the system to ignore the `name` filter. * **networkTunnelGroupIds** - The comma-separated list of network tunnel group IDs. * **exactAuthIdPrefix** - The case-sensitive value of the network tunnel hub auth ID prefix or the IP. * **region** - The region for the network tunnel group. The value of `region` is a sequence of case-insensitive characters. * **status** - The status of the network tunnel group. Valid values are \"connected\", \"disconnected\", and \"warning\". * **duplicateCIDRs** - List the network tunnel groups that have duplicate CIDRs.   Provide the CIDRs and optionally provide the regional scope and region properties.   Enabling the regional scope allows the system to find only duplicates within the same region.   You can not use the `duplicateCIDRs` filter with any other filter.  Specify the filters in the JSON format.  Example:  ``` {     \"name\": \"Branch 1 Network Tunnel Group\",     \"region\": \"us-east-1\" } ``` or  Example:  ``` {     \"duplicateCIDRs\":     {         \"cidrs\": \"10.0.0.0/8,10.01.0.0/16\",         \"regionalScope\": true,         \"region\": \"us-east\"     } }
        :type filters: FiltersNTGsObject
        :param offset: An integer that represents the place to start reading in the collection. When the offset is set to `0`, the system returns the first page from the collection. If the `limit` is 10, the `offset` for the next page is 10. The default value is 0.
        :type offset: int
        :param limit: An integer that represents the number of records to return in the response. The default value is 10.
        :type limit: int
        :param sort_by: Specify the field the system will use to sort the items from the collection in the response.
        :type sort_by: str
        :param sort_order: Specify the sort order (ascending or descending) for the items in the response.
        :type sort_order: str
        :param include_statuses: Specify whether to include the IPsec tunnel status field (`tunnelsStatus`) for each hub.
        :type include_statuses: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_network_tunnel_groups_serialize(
            filters=filters,
            offset=offset,
            limit=limit,
            sort_by=sort_by,
            sort_order=sort_order,
            include_statuses=include_statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupsList",
            '400': "Model400ListError",
            '401': "Model401Error",
            '403': "Model403Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_network_tunnel_groups_without_preload_content(
        self,
        filters: Annotated[Optional[FiltersNTGsObject], Field(description="Filter the network tunnel groups by one or more properties:  * **name** - The name of a network tunnel group. The value of `name` is a sequence of case-insensitive characters. * **exactName** - The sequence of case-insensitive characters that exactly match the name of the network tunnel group.   Including `exactName` as a filter, causes the system to ignore the `name` filter. * **networkTunnelGroupIds** - The comma-separated list of network tunnel group IDs. * **exactAuthIdPrefix** - The case-sensitive value of the network tunnel hub auth ID prefix or the IP. * **region** - The region for the network tunnel group. The value of `region` is a sequence of case-insensitive characters. * **status** - The status of the network tunnel group. Valid values are \"connected\", \"disconnected\", and \"warning\". * **duplicateCIDRs** - List the network tunnel groups that have duplicate CIDRs.   Provide the CIDRs and optionally provide the regional scope and region properties.   Enabling the regional scope allows the system to find only duplicates within the same region.   You can not use the `duplicateCIDRs` filter with any other filter.  Specify the filters in the JSON format.  Example:  ``` {     \"name\": \"Branch 1 Network Tunnel Group\",     \"region\": \"us-east-1\" } ``` or  Example:  ``` {     \"duplicateCIDRs\":     {         \"cidrs\": \"10.0.0.0/8,10.01.0.0/16\",         \"regionalScope\": true,         \"region\": \"us-east\"     } }")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="An integer that represents the place to start reading in the collection. When the offset is set to `0`, the system returns the first page from the collection. If the `limit` is 10, the `offset` for the next page is 10. The default value is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="An integer that represents the number of records to return in the response. The default value is 10.")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Specify the field the system will use to sort the items from the collection in the response.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Specify the sort order (ascending or descending) for the items in the response.")] = None,
        include_statuses: Annotated[Optional[StrictBool], Field(description="Specify whether to include the IPsec tunnel status field (`tunnelsStatus`) for each hub.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Network Tunnel Groups

        List the Network Tunnel Groups in the organization. If you enable the `includeStatuses` query parameter in your API request, the response includes the `tunnelsStatus` field. The maximum number of items in a hub's list of tunnel states (`tunnelsStatus`) is 10.

        :param filters: Filter the network tunnel groups by one or more properties:  * **name** - The name of a network tunnel group. The value of `name` is a sequence of case-insensitive characters. * **exactName** - The sequence of case-insensitive characters that exactly match the name of the network tunnel group.   Including `exactName` as a filter, causes the system to ignore the `name` filter. * **networkTunnelGroupIds** - The comma-separated list of network tunnel group IDs. * **exactAuthIdPrefix** - The case-sensitive value of the network tunnel hub auth ID prefix or the IP. * **region** - The region for the network tunnel group. The value of `region` is a sequence of case-insensitive characters. * **status** - The status of the network tunnel group. Valid values are \"connected\", \"disconnected\", and \"warning\". * **duplicateCIDRs** - List the network tunnel groups that have duplicate CIDRs.   Provide the CIDRs and optionally provide the regional scope and region properties.   Enabling the regional scope allows the system to find only duplicates within the same region.   You can not use the `duplicateCIDRs` filter with any other filter.  Specify the filters in the JSON format.  Example:  ``` {     \"name\": \"Branch 1 Network Tunnel Group\",     \"region\": \"us-east-1\" } ``` or  Example:  ``` {     \"duplicateCIDRs\":     {         \"cidrs\": \"10.0.0.0/8,10.01.0.0/16\",         \"regionalScope\": true,         \"region\": \"us-east\"     } }
        :type filters: FiltersNTGsObject
        :param offset: An integer that represents the place to start reading in the collection. When the offset is set to `0`, the system returns the first page from the collection. If the `limit` is 10, the `offset` for the next page is 10. The default value is 0.
        :type offset: int
        :param limit: An integer that represents the number of records to return in the response. The default value is 10.
        :type limit: int
        :param sort_by: Specify the field the system will use to sort the items from the collection in the response.
        :type sort_by: str
        :param sort_order: Specify the sort order (ascending or descending) for the items in the response.
        :type sort_order: str
        :param include_statuses: Specify whether to include the IPsec tunnel status field (`tunnelsStatus`) for each hub.
        :type include_statuses: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_network_tunnel_groups_serialize(
            filters=filters,
            offset=offset,
            limit=limit,
            sort_by=sort_by,
            sort_order=sort_order,
            include_statuses=include_statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupsList",
            '400': "Model400ListError",
            '401': "Model401Error",
            '403': "Model403Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_network_tunnel_groups_serialize(
        self,
        filters,
        offset,
        limit,
        sort_by,
        sort_order,
        include_statuses,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if include_statuses is not None:
            
            _query_params.append(('includeStatuses', include_statuses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'oauthFlow'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/deployments/v2/networktunnelgroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_network_tunnel_group(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        patch_network_tunnel_group_request_inner: Annotated[List[PatchNetworkTunnelGroupRequestInner], Field(description="Update the properties of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NetworkTunnelGroupResponse:
        """Update Network Tunnel Group

        Update a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param patch_network_tunnel_group_request_inner: Update the properties of the Network Tunnel Group. (required)
        :type patch_network_tunnel_group_request_inner: List[PatchNetworkTunnelGroupRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_network_tunnel_group_serialize(
            id=id,
            patch_network_tunnel_group_request_inner=patch_network_tunnel_group_request_inner,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupResponse",
            '400': "Model400ValidationError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '409': "Model409Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_network_tunnel_group_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        patch_network_tunnel_group_request_inner: Annotated[List[PatchNetworkTunnelGroupRequestInner], Field(description="Update the properties of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NetworkTunnelGroupResponse]:
        """Update Network Tunnel Group

        Update a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param patch_network_tunnel_group_request_inner: Update the properties of the Network Tunnel Group. (required)
        :type patch_network_tunnel_group_request_inner: List[PatchNetworkTunnelGroupRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_network_tunnel_group_serialize(
            id=id,
            patch_network_tunnel_group_request_inner=patch_network_tunnel_group_request_inner,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupResponse",
            '400': "Model400ValidationError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '409': "Model409Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_network_tunnel_group_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="The ID of the Network Tunnel Group.")],
        patch_network_tunnel_group_request_inner: Annotated[List[PatchNetworkTunnelGroupRequestInner], Field(description="Update the properties of the Network Tunnel Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Network Tunnel Group

        Update a Network Tunnel Group in the organization.

        :param id: The ID of the Network Tunnel Group. (required)
        :type id: int
        :param patch_network_tunnel_group_request_inner: Update the properties of the Network Tunnel Group. (required)
        :type patch_network_tunnel_group_request_inner: List[PatchNetworkTunnelGroupRequestInner]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_network_tunnel_group_serialize(
            id=id,
            patch_network_tunnel_group_request_inner=patch_network_tunnel_group_request_inner,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkTunnelGroupResponse",
            '400': "Model400ValidationError",
            '401': "Model401Error",
            '403': "Model403Error",
            '404': "Model404Error",
            '409': "Model409Error",
            '500': "Model500Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_network_tunnel_group_serialize(
        self,
        id,
        patch_network_tunnel_group_request_inner,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PatchNetworkTunnelGroupRequestInner': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_network_tunnel_group_request_inner is not None:
            _body_params = patch_network_tunnel_group_request_inner


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'oauthFlow'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/deployments/v2/networktunnelgroups/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


